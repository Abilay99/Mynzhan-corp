С++ философиясы Бьерн Страуструп дизайн және C++тың эволюциясы кiтабында ол C++ның жобалауында ұстап тұратын қағидаларды суреттейдi. Бұл қағидалар C++ты дәл сондай болатындай етіп ұғындырады. Кейбiреулері: •Мәлiметтердiң статикалық түрлерi бар әмбебап тiлi арқылы, тиiмдiлiкпен және C++ тiлiнiң тасымалданғыштығымен алу.  •Программалаудың стильлерiнiң жиынын тiкелей және жан-жақты қолдау, соның iшiнде процедураны программалау, мәлiметтердiң абстракциясы, объективтi-хабар программалау.  •Егер таңдаудың бостандығын бағдарламашыға,жалпыланған программалау  бұл берiлген таңдау мүмкiндiгiн оған терiс бередi.  •C пен үйлесiмдiктi C++қа программалаудан жеңiл өтуді нақ сондай етіп барынша сақтау.  •Олардың әрқайсыларында тiптi бiр белгi қойылсада және бағдарламаның ылғи бiр мiнез-құлығына алып келу тиiстi екi тiлдерге тиiстi мүмкiн кез келген конструкция C және C++:нiң аралығында түрлi оқулардан құтылу. •Платформаларға тәуелдi болатын немесе әмбебап болып табылмаған ерекшелiктерді бой жасыру.  •Ешқандай да тiл құралы ол қолданушы емес, бағдарламалардың өнiмдiлiктi төмендетуiне алып келуi керек.  •Өте күрделендiрiлген программалау ортасын талап етпеу.  Объективтi-хабар мүмкiндiктері: Бөлiмде бұл мүмкiндiктер суреттеледi, (ооп ) объективтi-хабар программалауы бар, байланыспағанды тiкелей, алайда, әсiресе маңызды ооп пен қатар мүмкіндік жасайды.  Түрлері: C++қа түсiнiктi келесi кiрiстiрiлген түрлер: Нышандығы: char, wchar_t.  Бүтiн санды таңбалысы: signed char, short int, int, (және long long int, C++11дiң стандартында) long int.  Бүтiн санды таңбасызы: unsigned char, unsigned short int, unsigned int, (және unsigned long long int, C++11дiң стандартында) unsigned long int.  Жүзитiн нүктемен: float, double, long double.  Логикалығы: true және false bool, болатын мәндер. Салыстыру операциялары boolдың түрлерiн қайтарады. Өрнектер boolдың түрлерiне жақшаларда if, whileден кейiн тура келедi. Функциялар сiлтеме бойынша дәлелдер қабылдай алады. Мысалы, x=3 (int x ) void f функция} 3-шi мәндi өз дәлелiне тағайындайды. Сонымен бiрге функциялар сiлтеме бойынша нәтиже қайтара алады, және сiлтеме функциялары бар тыс әр түрлi байланыс бола алады. Мысалы, [3 ] double b=a; (b ) b=sin;} ([3 ] a) =sin [3 ]  баламалы;. Белгiлi дәрежегедегi сiлтемелерi программалауда нұсқағыштармен, келесi ерекшелiктермен ұқсас: сiлтеме қолданудың алдында аты-жөнiн көрсетуi керек; сiлтеме ылғи бiр мекенжай өмiр бойы көрсетеді; сiлтеме өрнекте сол объект немесе оған көрсететiн функциясын объектке немесе функцияның үндеуi нұсқағыштың есiмсiздеуi нұсқағыш арқылы талап етедi, тiкелей белгi қояды. Нұсқағыштар және сiлтемелердiң қолдануындағы тағы басқа айырмашылықтар бар болады. Сiлтеме концептуалды - басқа айнымалының аты немесе функция, ылғи бiр мекенжайды басқа атайды, тек қана бағдарламаның мәтiнiнде бар болады  Әртүрлiсi: Функция-Inline спецификатор inline жариялауға мүмкiндiк бередi. Сынып, дененiң iшi нақтылы, функция үндемеу бойынша inline болып табылады. Inline бастапқы - функциялар сияқты ойланып, компилятор функцияға қарап сөйлеу, орындарындағы жанында бұл функцияның денесiн қойған ықшамдауға жақсы кандидаттарды шақыру код емес болатын. Компилятор шындығында inline үшiн дененiң алмастыруын iске асыруға мiндеттi емес. Бiрақ мүмкiн жағдайы, inline сияқты жарияламайтын функциялар үшiн дененiң алмастыруын ықшамдаудан қалған белгiлерiнен сүйене орындау. Абзалы, inlineнiң өте мағыналы ерекшелiгi — функциялар, ол ЄдЄбұл inlineлерде - функция оны қолданылатындығынан хабар жүргiзеді, барлық бiрлiктерiндегi анықтауы керек. Хабар жүргiзудiң бiрнеше бiрлiктерiнде дүркiн-дүркiн анықтала алатын болып табылады, осы уақытта inline болмайтын функция бағдарламада бiр реттен аспайтындай етіп анықтала алады. Volatile суреттеме айнымалы сипаттамасында қолданылады және мән осы айнымалы компиляторды iздеп таба алмайтын әдiспен өзгертiле алады ретiнде компиляторды мәлiмет бередi. Мысалы, volatile жариялалған айнымалы компиляторлар үшiн айнымалы оның мән екi оны қақшулардың арасындағы аралықтағы айнымалы мәнiнiң өзгерiссiздiк тиесiлi регистрлерiнде ) сыйғызып салатын жадтарындағы жағдай құбылғыш ықшамдаулар құрал қолдануы керек. struct Time { };Time t1, t2; namespace Foo{ } using namespace Foo; Аттардың кеңiстiгi. функциялар және түрлер дәл келетiн аттар, глобалдi айнымалы болатын пакеттердiң арасындағы қайшылықтар пайда болмау үшiн керек.  Бұл суреттеп айтылған барлық аттар хабар жүргiзудiң ағымдағы бiрлiгiнде түсiнiктi. Бiр немесе бiрнеше соңғы дәлелдердiң функциялары үндемеу бойыншаға бөсе алады. Егер функция (int x, int y=5, int z=10) void f сияқты сипатталса, мысалға, (1 ) fтiң шақыруы, (1, 5) f және (1, 5, 10) f баламалы болады.struct S{ };S::T y; Дәлелдердiң жоқтығының функцияларының сипаттамасында жақшаларды бiлдiредi, старға қарағанда. Мысалы, егер дәлелдер const char* fmt int printf көп нүктемен ....  белгiсiз болса, пайдалану керек..). void Print(int x);void Print(double x);void Print(int x, int y); Құрылымның iшiмен немесе сынып қабаттасқан typedef арқылы түрлер суреттеуге болады, сол сияқты басқа класстар, сонымен бiрге тiзiмдер сипаттама арқылы суреттеледі. struct Date {int day, month, year;};void operator ++(struct Date& date); Ылғи бiр аты бар бiрнеше функциялар бола алады, бiрақ функциялардың шамадан тыс жүктеуi әртүрлi түрлер немесе дәлелдердiң санымен; шамадан тыс жүктеуге бұл түрде қайтарылатын мәндер ықпал етпейдi. Қолданбалы түрлерге кейбiр операторлардың мағынасына қарай тиiстi операторлық функциялар, хабарлау арқылы анықтауға болады. Операторлық функциялар көпшiлiгiнде  кәдiмгi функцияларға ұқсас. New, newтың операторы, delete және delete қоспағанды қайта анықтау мүмкiн емес; (айталық, **) C++ жоқ болатын жаңа операторлар ойлап шығаруға болмайды; операндтарды оператор үшiн ескерiлген санмен өзгертуге болмайды, сонымен бiрге (айталық, a+b*cтың өрнегiнде бастапқыда көбейту орындалар едi, түрлерге a, b және cтер жатпайтын қосу сонан соң орындалады) операторлардың қазiргi басымдылықтарын және ассоциациялығын өзгертуге болмайды. (бiр параметрмен) операцияны қайта анықтауға болады  және (параметрлердiң кез келген санымен). (template ) үлгiлер қосылған. Мысалы, y return x (T x, T y) T Min <class T > template ме?олар:қасында;} кез келген түрлер үшiн Minнiң функциясын анықтайды. үлгiлер функцияға ғана емес, түрлерге де тапсырма бере алады. Мысалы, int len struct Array <class T > template T* val}; кез келген түрдiң мәндерiнiң массивын анықтайды, не бiз кейiн x <float > Array  аламыз  Malloc және free функцияларға қосымша ретiнде operator new,  operator newтың операторлық функциясы, operator delete және operator delete, сонымен бiрге new,  newтың операторы, delete және delete енгiзiлген. Егер T - болса X-шы кез келген массивтың түр болмайтын объектiнiң түрi - болса кез келген объектiнiң түр және Aсi - болса X-шы түр болатын элементтердiң nның саны массивтың түрi кейбiр болады мысалы, new T (operator newтың функцияны шақыруы арқылы ), Т-тың түрдiң бiр объектiнiң орналастыруы үшiн жеткiлiктi болуы мүмкiн, жад объект бұл аты-жөнiн көрсетедi және Т*ның түрiнiң нұсқағышын қайтара алады, жадтың әрбiр объекті бұл аты-жөнiді көрсетедi, және [n ] X* p = new Xтың X*сы түрдiң нұсқағыштарын қайтарады) жадты ерекшелейдi. мысалы, p = new T Т*.  [n ] new X және new A ([] ] operator newтың функцияын шақыру арқылы) жадтарды ерекшелейдi, delete pның түрiнiң объекттерiнiң n-ның орналастыруы үшiн жеткiлiктi X, - p-ның нұсқағышы сiлтейтiн (болмайтын массивпен) объект және өрнектi (operator deleteның функциясын шақыруы арқылы) жадтың оны newтар үшiн бұрын ерекшеленген облысын босатады  delete p - pның нұсқағышы сiлтейтiн массивтағы әрбiр объект және өрнектi  operator deleteның функцияны шақыруы арқылы) жадтың newтың массивы ол үшiн бұрын ерекшеленген облысын босатады. 

